#!/bin/bash

SHELL_TYPE=$1

LINE="\342\224\200"
CORNER_UL="\342\224\214"
CORNER_UR="\342\224\220"
CORNER_LL="\342\224\224"
CORNER_LR="\342\224\230"

if [ "$SHELL_TYPE" == "zsh" ]; then
  ESC="%%{"
  CSE="%%}"
else
  ESC="\["
  CSE="\]"
fi

RESET="$ESC\033[0m$CSE"
GREEN="$ESC\033[1;32m$CSE"
YELLOW="$ESC\033[1;33m$CSE"
PINK="$ESC\033[1;35m$CSE"
CYAN="$ESC\033[1;36m$CSE"
RED="$ESC\033[1;31m$CSE"
PURPLE="$ESC\033[1;34m$CSE"

if [ "$PROMPT_STYLE" == "server" ]; then
  LINE_COLOR="$RED"
  FRAME_COLOR="$PINK"
else
  LINE_COLOR="$CYAN"
  FRAME_COLOR="$PURPLE"
fi

FRAME_BEGIN="$FRAME_COLOR$LINE("
FRAME_END="$FRAME_COLOR)$LINE$LINE_COLOR$LINE"

if [ "$COLUMNS" == "" ]; then
  COLUMNS=$(tput cols)
fi

function insertOptionalNewline() {
  exec < /dev/tty
  oldstty=$(stty -g)
  stty raw -echo min 0
  echo -en "\033[6n" > /dev/tty
  IFS=';' read -r -d R -a pos
  stty $oldstty
  if [ "${pos[1]}" != "1" ]; then
    echo
  fi
}

# Fork for performance (cygwin sucks)
insertOptionalNewline &

if [ -z "$PROMPT_USER" ]; then
  PROMPT_USER="$USER@$HOSTNAME"
fi

prompt="\n\033[1A$LINE_COLOR$CORNER_UL$FRAME_BEGIN$GREEN$PROMPT_USER$FRAME_END"
padding=$(($COLUMNS - ${#PROMPT_USER} - 7))

if [ -f "$HOME/.dotfiles_dirty" ]; then
  prompt="$prompt$FRAME_BEGIN${PINK}!$FRAME_END"
  padding=$(($padding - 6))
fi

if [ "$DEVENV" != "" ]; then
  prompt="$prompt$FRAME_BEGIN$YELLOW$DEVENV$FRAME_END"
  padding=$(($padding - ${#DEVENV} - 5))
fi

if [ "${PWD:0:${#HOME}}" == "$HOME" ]; then
  directory="~${PWD:${#HOME}}"
else
  directory="${PWD}"
fi
directoryLength=$((${#directory} + 4))

branch="$(git symbolic-ref HEAD 2>/dev/null)"
if [[ "$branch" != "" && $(($padding - ${#branch})) -gt 5 ]]; then
  branch=${branch##refs/heads/}
  branchPrompt="$FRAME_BEGIN$PINK$branch$FRAME_END"
  padding=$(($padding - ${#branch} - 5))
else
  branchPrompt=""
fi

if [ $padding -gt $directoryLength ]; then
  for ((i=$directoryLength; i < $padding; i++)) {
    prompt="$prompt$LINE"
  }
  prompt="$prompt$branchPrompt$FRAME_BEGIN$PINK$directory$FRAME_COLOR)$LINE"
else
  if [ $padding -lt 8 ]; then
    for ((i=0; i < padding; i++)) {
      prompt="$prompt$LINE"
    }
  else
    prompt="$prompt$branchPrompt$FRAME_BEGIN$PINK...${directory:$((7-$padding))}$FRAME_COLOR)$LINE"
  fi
fi

DATE=$(date +"%Y-%m-%d")
prompt="$prompt$LINE_COLOR$CORNER_UR\033[1B\033[$(($COLUMNS - 15))G$LINE_COLOR$LINE$FRAME_BEGIN$YELLOW$DATE$FRAME_COLOR)$LINE$LINE_COLOR$CORNER_LR\033[1A\n$LINE_COLOR$CORNER_LL"

if [[ ! -z "$PROMPT_EXIT" && "$PROMPT_EXIT" != "0" ]]; then
  prompt="$prompt$FRAME_BEGIN${PINK}$PROMPT_EXIT$FRAME_END"
fi

TIME=$(date +"%H:%M:%S")
prompt="$prompt$FRAME_BEGIN$YELLOW$TIME$FRAME_END$RESET "

# Wait for forked optionalNewLine
wait

printf "$prompt"
